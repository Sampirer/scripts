#!/bin/bash
# update-readme.sh - Automatische README.md Generierung für verschiedene Repository-Typen
# Unterstützt dotfiles, scripts und arch-install Repositories

set -e

# Tokyo Night Storm Farben
readonly RED='\033[38;2;247;118;142m'
readonly GREEN='\033[38;2;158;206;106m'
readonly YELLOW='\033[38;2;224;175;104m'
readonly BLUE='\033[38;2;122;162;247m'
readonly PURPLE='\033[38;2;187;154;247m'
readonly CYAN='\033[38;2;125;207;255m'
readonly WHITE='\033[38;2;192;202;245m'
readonly GRAY='\033[38;2;86;95;137m'
readonly RESET='\033[0m'

# Hilfsfunktionen
log_info()    { echo -e "${BLUE}[INFO]${RESET} $1"; }
log_success() { echo -e "${GREEN}[OK]${RESET} $1"; }
log_warning() { echo -e "${YELLOW}[WARN]${RESET} $1"; }
log_error()   { echo -e "${RED}[ERROR]${RESET} $1"; }
log_section() { echo -e "\n${PURPLE}=== $1 ===${RESET}"; }

# Git Remote URL ermitteln
get_repo_url() {
    local repo_dir="$1"
    cd "$repo_dir"
    local url=$(git remote get-url origin 2>/dev/null || echo "")
    # SSH zu HTTPS konvertieren für README-Links
    url=$(echo "$url" | sed 's|git@github.com:|https://github.com/|' | sed 's|\.git$||')
    echo "$url"
}

# Prüfe ob Datei in .gitignore ist
is_ignored() {
    local repo_dir="$1"
    local file="$2"
    cd "$repo_dir"
    git check-ignore -q "$file" 2>/dev/null
}

# Repository-Typ erkennen - WICHTIG: Reihenfolge beachten!
detect_repo_type() {
    local repo_dir="$1"
    
    # 1. Prüfe zuerst auf arch-install (hat arch-install.sh oder install.sh)
    if [[ -f "$repo_dir/arch-install.sh" ]] || [[ -f "$repo_dir/install.sh" ]]; then
        echo "arch-install"
        return
    fi
    
    # 2. Prüfe auf scripts (.local/bin Verzeichnis)
    if [[ -d "$repo_dir/.local/bin" ]]; then
        echo "scripts"
        return
    fi
    
    # 3. Ansonsten dotfiles (hat Stow-Pakete)
    if find "$repo_dir" -maxdepth 1 -type d ! -name '.*' ! -name 'screenshots' | grep -q .; then
        echo "dotfiles"
        return
    fi
    
    echo "unknown"
}

# Screenshot-Funktion
take_screenshot() {
    local repo_dir="$1"
    local screenshot_dir="$repo_dir/screenshots"
    
    mkdir -p "$screenshot_dir"
    
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local screenshot_file="$screenshot_dir/desktop_$timestamp.png"
    
    log_info "Erstelle Screenshot: $screenshot_file"
    
    if command -v flameshot >/dev/null 2>&1; then
        flameshot full -p "$screenshot_file"
    elif command -v scrot >/dev/null 2>&1; then
        scrot "$screenshot_file"
    elif command -v import >/dev/null 2>&1; then
        import -window root "$screenshot_file"
    else
        log_error "Kein Screenshot-Tool gefunden (flameshot, scrot, oder ImageMagick)"
        return 1
    fi
    
    log_success "Screenshot erstellt: $screenshot_file"
}

# Dotfiles Repository verarbeiten
process_dotfiles() {
    local repo_dir="$1"
    local readme_file="$repo_dir/README.md"
    local repo_url=$(get_repo_url "$repo_dir")
    
    log_section "Verarbeite Dotfiles Repository"
    
    # Kategorien definieren (erweitert!)
    declare -A categories
    categories["shell"]="bash zsh fish"
    categories["terminal"]="alacritty kitty wezterm tmux"
    categories["wm"]="qtile i3 sway hyprland bspwm"
    categories["desktop"]="picom dunst rofi polybar waybar"
    categories["tools"]="git vim nvim neovim starship blesh"
    categories["other"]=""
    
    cat > "$readme_file" << EOF
# Dotfiles

Meine persönlichen Konfigurationsdateien für Arch Linux mit Qtile, verwaltet mit GNU Stow.

## Screenshot

EOF

    # Screenshot einbinden (erstes gefundenes)
    local screenshot_dir="$repo_dir/screenshots"
    if [[ -d "$screenshot_dir" ]]; then
        local first_screenshot=$(ls -1 "$screenshot_dir"/*.png 2>/dev/null | head -1)
        if [[ -n "$first_screenshot" ]]; then
            echo "![Desktop](screenshots/$(basename "$first_screenshot"))" >> "$readme_file"
            echo "" >> "$readme_file"
        fi
    fi

    cat >> "$readme_file" << EOF
## Installation

\`\`\`bash
# Repository klonen
git clone $repo_url ~/repos/dotfiles
cd ~/repos/dotfiles

# Alle Konfigurationen installieren
stow -t ~ */

# Oder einzelne Pakete installieren
stow -t ~ <package-name>
\`\`\`

## Pakete

EOF

    # Pakete nach Kategorien sortieren
    declare -A categorized_packages
    for stow_dir in "$repo_dir"/*/; do
        [[ ! -d "$stow_dir" ]] && continue
        local package_name=$(basename "$stow_dir")
        [[ "$package_name" == "screenshots" ]] && continue
        [[ "$package_name" == ".git" ]] && continue
        
        local category="other"
        for cat in "${!categories[@]}"; do
            if [[ " ${categories[$cat]} " =~ " $package_name " ]]; then
                category="$cat"
                break
            fi
        done
        
        categorized_packages["$category"]+="$package_name "
    done
    
    # Kategorien in Reihenfolge ausgeben
    for category in shell terminal wm desktop tools other; do
        [[ -z "${categorized_packages[$category]}" ]] && continue
        
        case "$category" in
            shell)    echo "### Shell" >> "$readme_file" ;;
            terminal) echo "### Terminal" >> "$readme_file" ;;
            wm)       echo "### Window Manager" >> "$readme_file" ;;
            desktop)  echo "### Desktop" >> "$readme_file" ;;
            tools)    echo "### Tools" >> "$readme_file" ;;
            other)    echo "### Weitere" >> "$readme_file" ;;
        esac
        echo "" >> "$readme_file"
        
        for package_name in ${categorized_packages[$category]}; do
            local stow_dir="$repo_dir/$package_name"
            echo "#### $package_name" >> "$readme_file"
            echo "" >> "$readme_file"
            
            # Dateien auflisten (OHNE .gitignore Dateien!)
            echo "Dateien:" >> "$readme_file"
            while IFS= read -r file; do
                local rel_path="${file#$stow_dir/}"
                # Prüfe ob in .gitignore
                if ! is_ignored "$repo_dir" "$package_name/$rel_path"; then
                    echo "- \`$rel_path\`" >> "$readme_file"
                fi
            done < <(find "$stow_dir" -type f -not -path '*/.git/*' | sort)
            echo "" >> "$readme_file"
        done
    done
    
    # Footer
    cat >> "$readme_file" << EOF
## Theme

Tokyo Night Storm

## Verwandte Repositories

- [arch-install](https://github.com/Sampirer/arch-install) - Installations-Script
- [scripts](https://github.com/Sampirer/scripts) - Utility Scripts

---
*Generiert am: $(date '+%d.%m.%Y %H:%M:%S')*
EOF

    log_success "README.md erstellt: $readme_file"
}

# Scripts Repository verarbeiten
process_scripts() {
    local repo_dir="$1"
    local readme_file="$repo_dir/README.md"
    local scripts_dir="$repo_dir/.local/bin"
    local repo_url=$(get_repo_url "$repo_dir")
    
    log_section "Verarbeite Scripts Repository"
    
    [[ ! -d "$scripts_dir" ]] && { log_error "Scripts-Verzeichnis nicht gefunden"; return 1; }
    
    cat > "$readme_file" << EOF
# Scripts

Sammlung nützlicher Shell-Scripts für Arch Linux.

## Installation

\`\`\`bash
# Repository klonen
git clone $repo_url ~/repos/scripts
cd ~/repos/scripts

# Scripts verfügbar machen
stow -t ~ .
\`\`\`

## Übersicht

| Script | Beschreibung |
|--------|--------------|
EOF

    # Übersichtstabelle erstellen
    for script in "$scripts_dir"/*; do
        [[ ! -f "$script" ]] && continue
        [[ ! -x "$script" ]] && continue
        
        local script_name=$(basename "$script")
        local description=$(head -5 "$script" | grep "^#" | grep -v "^#!/" | grep -v "^# *$" | head -1 | sed 's/^# *//')
        [[ -z "$description" ]] && description="Shell script"
        
        echo "| \`$script_name\` | $description |" >> "$readme_file"
    done
    
    echo "" >> "$readme_file"
    echo "## Scripts im Detail" >> "$readme_file"
    echo "" >> "$readme_file"
    
    # Detaillierte Beschreibungen
    for script in "$scripts_dir"/*; do
        [[ ! -f "$script" ]] && continue
        [[ ! -x "$script" ]] && continue
        
        local script_name=$(basename "$script")
        echo "### $script_name" >> "$readme_file"
        echo "" >> "$readme_file"
        
        # Beschreibung extrahieren (alle Kommentarzeilen am Anfang)
        local description=$(head -10 "$script" | grep "^#" | grep -v "^#!/" | grep -v "^# *$" | head -1 | sed 's/^# *//')
        if [[ -n "$description" ]]; then
            echo "$description" >> "$readme_file"
            echo "" >> "$readme_file"
        fi
        
        # Usage
        echo "**Verwendung:**" >> "$readme_file"
        echo "\`\`\`bash" >> "$readme_file"
        
        # Prüfe ob das Script eine help/usage Funktion hat
        if grep -q "show_help\|usage()\|--help" "$script" 2>/dev/null; then
            echo "$script_name [command] [options]" >> "$readme_file"
            echo "" >> "$readme_file"
            # Befehle extrahieren wenn vorhanden
            local commands=$(grep -E "^\s+[a-z_-]+\)" "$script" 2>/dev/null | head -5 | sed 's/).*$//' | tr -d ' ' | tr '\n' ', ' | sed 's/,$//')
            if [[ -n "$commands" ]]; then
                echo "# Befehle: $commands" >> "$readme_file"
            fi
        else
            echo "$script_name" >> "$readme_file"
        fi
        echo "\`\`\`" >> "$readme_file"
        echo "" >> "$readme_file"
    done
    
    # Footer
    cat >> "$readme_file" << EOF
## Verwandte Repositories

- [dotfiles](https://github.com/Sampirer/dotfiles) - Konfigurationsdateien
- [arch-install](https://github.com/Sampirer/arch-install) - Installations-Script

---
*Generiert am: $(date '+%d.%m.%Y %H:%M:%S')*
EOF

    log_success "README.md erstellt: $readme_file"
}

# Arch-Install Repository verarbeiten
process_arch_install() {
    local repo_dir="$1"
    local readme_file="$repo_dir/README.md"
    local repo_url=$(get_repo_url "$repo_dir")
    local raw_url="${repo_url/github.com/raw.githubusercontent.com}/main"
    
    log_section "Verarbeite Arch-Install Repository"
    
    # Version aus Script extrahieren
    local version="2.2"
    if [[ -f "$repo_dir/arch-install.sh" ]]; then
        version=$(grep -m1 "Script v[0-9]" "$repo_dir/arch-install.sh" 2>/dev/null | grep -oP 'v\K[0-9.]+' || echo "2.2")
    fi
    
    cat > "$readme_file" << EOF
# Arch Linux Minimal Install Script v$version

Interaktives Installationsscript für ein minimales Arch Linux Setup mit Qtile.

## Screenshot

EOF

    # Screenshot einbinden
    local screenshot_dir="$repo_dir/screenshots"
    if [[ -d "$screenshot_dir" ]]; then
        local first_screenshot=$(ls -1 "$screenshot_dir"/*.png 2>/dev/null | head -1)
        if [[ -n "$first_screenshot" ]]; then
            echo "![Terminal](screenshots/$(basename "$first_screenshot"))" >> "$readme_file"
            echo "" >> "$readme_file"
        fi
    fi

    cat >> "$readme_file" << EOF
## Features

- **Interaktive Konfiguration** – Alle Einstellungen werden abgefragt
- **Hardware-Erkennung** – CPU und GPU werden automatisch erkannt
- **Multi-GPU-Support** – Intel, AMD, NVIDIA, Hybrid (Optimus)
- **Btrfs + Snapper** – Automatische Snapshots mit GRUB-Integration
- **Qtile Desktop** – Minimaler Tiling Window Manager
- **Dotfiles-Integration** – Optional: Dotfiles automatisch einrichten

## Schnellstart

\`\`\`bash
# Arch ISO booten, Netzwerk verbinden, dann:
curl -LO $raw_url/arch-install.sh
chmod +x arch-install.sh
./arch-install.sh
\`\`\`

## Unterstützte Hardware

| Komponente | Optionen |
|------------|----------|
| **CPU** | Intel, AMD (automatische Microcode-Auswahl) |
| **GPU** | Intel, AMD, NVIDIA, Intel+NVIDIA (Optimus) |
| **Disk** | NVMe, SATA, VirtIO |

## Partitionsschema

\`\`\`
┌─────────────────────────────────────────────────┐
│ Disk                                            │
├──────────┬──────────┬───────────────────────────┤
│ EFI 1GB  │ Swap     │ Root (Btrfs)              │
│ FAT32    │ ~RAM+2GB │ Subvolumes: @, @home, ... │
└──────────┴──────────┴───────────────────────────┘
\`\`\`

## Installierte Pakete

### Basis
\`\`\`
base linux linux-firmware grub btrfs-progs networkmanager
\`\`\`

### Desktop
\`\`\`
qtile alacritty picom dunst rofi feh thunar
pipewire wireplumber
\`\`\`

### Dotfiles-Abhängigkeiten (optional)
\`\`\`
starship fzf zoxide ttf-jetbrains-mono-nerd
flameshot udiskie pasystray
yay blesh (AUR)
\`\`\`

## Nach der Installation

Das Script kann automatisch die Dotfiles einrichten:
- Klont \`dotfiles\` und \`scripts\` Repositories
- Wendet alle Stow-Konfigurationen an
- Installiert AUR-Pakete (yay, blesh)

## Verwandte Repositories

- [dotfiles](https://github.com/Sampirer/dotfiles) - Konfigurationsdateien
- [scripts](https://github.com/Sampirer/scripts) - Utility Scripts

## Lizenz

MIT

---
*Generiert am: $(date '+%d.%m.%Y %H:%M:%S')*
EOF

    log_success "README.md erstellt: $readme_file"
}

# Hauptfunktion
main() {
    local take_screenshot_flag=false
    local target_dirs=()
    
    # Argument-Parsing
    while [[ $# -gt 0 ]]; do
        case $1 in
            --screenshot|-s)
                take_screenshot_flag=true
                shift
                ;;
            --help|-h)
                echo "Usage: update-readme [--screenshot] [repo-dir ...]"
                echo ""
                echo "Generiert README.md für dotfiles, scripts und arch-install Repos."
                echo ""
                echo "Optionen:"
                echo "  --screenshot, -s  Erstellt einen Desktop-Screenshot"
                echo "  --help, -h        Zeigt diese Hilfe"
                exit 0
                ;;
            *)
                target_dirs+=("$1")
                shift
                ;;
        esac
    done
    
    # Standard-Verzeichnisse
    if [[ ${#target_dirs[@]} -eq 0 ]]; then
        target_dirs=(
            "$HOME/repos/dotfiles"
            "$HOME/repos/scripts"
            "$HOME/repos/arch-install"
        )
    fi
    
    log_info "Update README.md"
    
    for repo_dir in "${target_dirs[@]}"; do
        if [[ ! -d "$repo_dir" ]]; then
            log_warning "Nicht gefunden: $repo_dir"
            continue
        fi
        
        local repo_type=$(detect_repo_type "$repo_dir")
        log_info "Erkannt: $repo_type → $(basename "$repo_dir")"
        
        # Screenshot erstellen wenn gewünscht
        if [[ "$take_screenshot_flag" == true ]]; then
            take_screenshot "$repo_dir"
        fi
        
        # Repository verarbeiten
        case "$repo_type" in
            dotfiles)     process_dotfiles "$repo_dir" ;;
            scripts)      process_scripts "$repo_dir" ;;
            arch-install) process_arch_install "$repo_dir" ;;
            *)            log_warning "Unbekannter Typ: $repo_dir" ;;
        esac
    done
    
    log_success "Fertig!"
}

main "$@"
