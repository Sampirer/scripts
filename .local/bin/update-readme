#!/bin/bash

# update-readme - Automatische README-Generierung für verschiedene Repository-Typen
# Generiert README.md Dateien basierend auf Repository-Inhalt und -Struktur

set -euo pipefail

# Tokyo Night Storm Farben für Output
RED='\033[38;2;247;118;142m'      # #f7768e
GREEN='\033[38;2;158;206;106m'    # #9ece6a
YELLOW='\033[38;2;224;175;104m'   # #e0af68
BLUE='\033[38;2;125;207;255m'     # #7dcfff
PURPLE='\033[38;2;187;154;247m'   # #bb9af7
CYAN='\033[38;2;115;218;202m'     # #73daca
NC='\033[0m' # No Color

# Flags
SCREENSHOT=false
REPO_PATH=""

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [REPO_PATH]

Generiert automatisch README.md Dateien für verschiedene Repository-Typen.

OPTIONS:
    -s, --screenshot    Macht einen Screenshot des aktuellen Desktops
    -h, --help         Zeigt diese Hilfe an

REPO_PATH:
    Pfad zum Repository (Standard: aktuelles Verzeichnis)

UNTERSTÜTZTE REPOSITORY-TYPEN:
    - dotfiles: Stow-basierte Konfigurationen
    - scripts: Shell-Scripts in .local/bin/
    - arch-install: Arch Linux Installationsscripts

BEISPIELE:
    $(basename "$0") ~/repos/dotfiles
    $(basename "$0") --screenshot ~/repos/scripts
    $(basename "$0") -s
EOF
}

log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

debug() {
    echo -e "${BLUE}[DEBUG]${NC} $1"
}

# Screenshot erstellen
take_screenshot() {
    local screenshot_dir="$1/screenshots"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local screenshot_file="desktop_${timestamp}.png"
    
    mkdir -p "$screenshot_dir"
    
    if command -v scrot >/dev/null 2>&1; then
        scrot "$screenshot_dir/$screenshot_file"
        log "Screenshot erstellt: $screenshot_file"
        echo "$screenshot_file"
    elif command -v gnome-screenshot >/dev/null 2>&1; then
        gnome-screenshot --file="$screenshot_dir/$screenshot_file"
        log "Screenshot erstellt: $screenshot_file"
        echo "$screenshot_file"
    else
        warn "Kein Screenshot-Tool gefunden (scrot oder gnome-screenshot)"
        echo ""
    fi
}

# Extrahiert Beschreibung aus Script-Header
extract_script_description() {
    local script_file="$1"
    
    # Suche nach Kommentar-Header in den ersten 10 Zeilen
    head -10 "$script_file" | grep -E "^#.*[a-zA-Z]" | head -1 | sed 's/^# *//' | sed 's/ *$//'
}

# Extrahiert benötigte Pakete aus Config-Dateien
extract_packages() {
    local config_dir="$1"
    local packages=()
    
    # Suche in verschiedenen Config-Dateien nach Paket-Referenzen
    if [[ -d "$config_dir" ]]; then
        # i3/sway configs
        find "$config_dir" -name "config" -o -name "*.conf" | while read -r file; do
            grep -ho "exec [a-zA-Z0-9_-]*" "$file" 2>/dev/null | cut -d' ' -f2 | sort -u
        done | sort -u
        
        # .desktop files
        find "$config_dir" -name "*.desktop" | while read -r file; do
            grep "^Exec=" "$file" 2>/dev/null | cut -d'=' -f2 | cut -d' ' -f1 | sort -u
        done | sort -u
    fi
}

# Generiert README für dotfiles Repository
generate_dotfiles_readme() {
    local repo_path="$1"
    local readme_file="$repo_path/README.md"
    local screenshot_file=""
    
    if [[ "$SCREENSHOT" == true ]]; then
        screenshot_file=$(take_screenshot "$repo_path")
    fi
    
    log "Generiere README für dotfiles Repository: $repo_path"
    
    cat > "$readme_file" << EOF
# Carsten's Dotfiles

Meine persönlichen Konfigurationsdateien für Arch Linux, verwaltet mit GNU Stow.

EOF

    # Screenshot einbinden falls vorhanden
    if [[ -n "$screenshot_file" ]]; then
        cat >> "$readme_file" << EOF
## Desktop Screenshot

![Desktop](screenshots/$screenshot_file)

EOF
    fi

    cat >> "$readme_file" << EOF
## Installation

\`\`\`bash
cd ~/repos/dotfiles
stow -t ~ .
\`\`\`

## Konfigurationen

EOF

    # Stow-Ordner auflisten
    for stow_dir in "$repo_path"/*; do
        if [[ -d "$stow_dir" && ! "$(basename "$stow_dir")" =~ ^(\.git|screenshots)$ ]]; then
            local dir_name=$(basename "$stow_dir")
            echo "### $dir_name" >> "$readme_file"
            echo "" >> "$readme_file"
            
            # Dateien in diesem Stow-Ordner auflisten
            if [[ -d "$stow_dir" ]]; then
                echo "**Enthaltene Dateien:**" >> "$readme_file"
                find "$stow_dir" -type f -printf "- %P\n" | sort >> "$readme_file"
                echo "" >> "$readme_file"
                
                # Benötigte Pakete extrahieren
                local packages=$(extract_packages "$stow_dir" | head -10)
                if [[ -n "$packages" ]]; then
                    echo "**Benötigte Pakete:**" >> "$readme_file"
                    echo "\`\`\`bash" >> "$readme_file"
                    echo "sudo pacman -S $packages" >> "$readme_file"
                    echo "\`\`\`" >> "$readme_file"
                    echo "" >> "$readme_file"
                fi
            fi
        fi
    done

    cat >> "$readme_file" << EOF

## Verwendung

Einzelne Konfigurationen können separat installiert werden:

\`\`\`bash
stow -t ~ <config-name>
\`\`\`

Zum Entfernen:

\`\`\`bash
stow -D -t ~ <config-name>
\`\`\`
EOF

    log "README generiert: $readme_file"
}

# Generiert README für scripts Repository
generate_scripts_readme() {
    local repo_path="$1"
    local readme_file="$repo_path/README.md"
    local bin_dir="$repo_path/.local/bin"
    
    log "Generiere README für scripts Repository: $repo_path"
    
    cat > "$readme_file" << EOF
# Carsten's System Scripts

Automatisierungs- und Wartungsscripts für Arch Linux.

## Installation
\`\`\`bash
cd ~/repos/scripts
stow -t ~ .
\`\`\`

## Scripts

| Script | Beschreibung |
|--------|--------------|
EOF

    # Scripts in .local/bin/ durchgehen
    if [[ -d "$bin_dir" ]]; then
        for script in "$bin_dir"/*; do
            if [[ -f "$script" && -x "$script" ]]; then
                local script_name=$(basename "$script")
                local description=$(extract_script_description "$script")
                
                # Fallback-Beschreibung falls keine gefunden
                if [[ -z "$description" ]]; then
                    description="System-Script"
                fi
                
                echo "| \`$script_name\` | $description |" >> "$readme_file"
            fi
        done
    fi

    cat >> "$readme_file" << EOF

## Verwendung

Nach der Installation sind alle Scripts über \`~/.local/bin/\` verfügbar.
Stelle sicher, dass \`~/.local/bin\` in deinem \`\$PATH\` ist:

\`\`\`bash
export PATH="\$HOME/.local/bin:\$PATH"
\`\`\`

### Beispiele

EOF

    # Usage-Beispiele für Scripts generieren
    if [[ -d "$bin_dir" ]]; then
        for script in "$bin_dir"/*; do
            if [[ -f "$script" && -x "$script" ]]; then
                local script_name=$(basename "$script")
                cat >> "$readme_file" << EOF
#### $script_name

\`\`\`bash
$script_name --help
\`\`\`

EOF
            fi
        done
    fi
}

# Generiert README für arch-install Repository
generate_arch_install_readme() {
    local repo_path="$1"
    local readme_file="$repo_path/README.md"
    
    log "Generiere README für arch-install Repository: $repo_path"
    
    cat > "$readme_file" << EOF
# Arch Linux Installation Script

Automatisiertes Installationsskript für Arch Linux mit meinen bevorzugten Einstellungen.

## Features

EOF

    # Features aus Scripts extrahieren
    for script in "$repo_path"/*.sh; do
        if [[ -f "$script" ]]; then
            local script_name=$(basename "$script" .sh)
            echo "### $script_name" >> "$readme_file"
            echo "" >> "$readme_file"
            
            # Funktionen aus dem Script extrahieren
            grep -E "^[a-zA-Z_][a-zA-Z0-9_]*\(\)" "$script" | sed 's/().*$//' | while read -r func; do
                echo "- $func" >> "$readme_file"
            done
            echo "" >> "$readme_file"
        fi
    done

    cat >> "$readme_file" << EOF

## Installierte Pakete

### Base System
EOF

    # Pakete aus Scripts extrahieren
    for script in "$repo_path"/*.sh; do
        if [[ -f "$script" ]]; then
            # Suche nach pacman -S Befehlen
            grep -ho "pacman -S[yu]* [a-zA-Z0-9 _-]*" "$script" 2>/dev/null | \
                sed 's/pacman -S[yu]* //' | \
                tr ' ' '\n' | \
                sort -u | \
                head -20 | \
                sed 's/^/- /' >> "$readme_file" || true
        fi
    done

    cat >> "$readme_file" << EOF

## Verwendung

\`\`\`bash
# Repository klonen
git clone <repo-url> arch-install
cd arch-install

# Script ausführbar machen
chmod +x install.sh

# Installation starten
./install.sh
\`\`\`

## Warnung

⚠️ **Dieses Script überschreibt bestehende Installationen!**
Nur auf frischen Systemen oder in VMs verwenden.
EOF

    log "README generiert: $readme_file"
}

# Repository-Typ erkennen
detect_repo_type() {
    local repo_path="$1"
    
    if [[ -d "$repo_path/.local/bin" ]]; then
        echo "scripts"
    elif [[ -f "$repo_path/install.sh" ]] || [[ -f "$repo_path/arch-install.sh" ]]; then
        echo "arch-install"
    elif find "$repo_path" -maxdepth 1 -type d ! -name ".*" | grep -q .; then
        # Hat Unterverzeichnisse (potentielle Stow-Ordner)
        echo "dotfiles"
    else
        echo "unknown"
    fi
}

# Hauptfunktion
main() {
    # Argument-Parsing
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--screenshot)
                SCREENSHOT=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unbekannte Option: $1"
                usage
                exit 1
                ;;
            *)
                REPO_PATH="$1"
                shift
                ;;
        esac
    done
    
    # Standard-Repository-Pfad
    if [[ -z "$REPO_PATH" ]]; then
        REPO_PATH="$(pwd)"
    fi
    
    # Repository-Pfad validieren
    if [[ ! -d "$REPO_PATH" ]]; then
        error "Repository-Pfad existiert nicht: $REPO_PATH"
        exit 1
    fi
    
    # Repository-Typ erkennen
    local repo_type=$(detect_repo_type "$REPO_PATH")
    log "Repository-Typ erkannt: $repo_type"
    
    # README basierend auf Typ generieren
    case "$repo_type" in
        dotfiles)
            generate_dotfiles_readme "$REPO_PATH"
            ;;
        scripts)
            generate_scripts_readme "$REPO_PATH"
            ;;
        arch-install)
            generate_arch_install_readme "$REPO_PATH"
            ;;
        *)
            error "Unbekannter Repository-Typ für: $REPO_PATH"
            exit 1
            ;;
    esac
    
    log "README-Generierung abgeschlossen!"
}

# Script ausführen
main "$@"
